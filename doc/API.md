# Overview
The Celeste system to query and process readings from Loggers connected to Solar Panels is described in this document. This system is a [RESTful](https://stackoverflow.com/questions/671118/what-exactly-is-restful-programming) API designed to access the information uploaded by the Loggers. In particular, this is a sub-system that is part of the whole energy-monitoring system. Please refer to the Table of Contents to see the different services offered. Also please see the section [Notes](#notes) to check various compatibility and implementation details.

# Table of Contents


1.  [Overview](#overview)
2.  [Device](#device)
3.  [Model](#model)
4.  [Point](#point)
5.  [Reading](#reading)
6.  [Logger](#logger)
7.  [Notes](#notes)

# Device

````
@ - - - - - - - - @
|  M is a Model   |
@ - - - - - - - - @

   Device
@-----------@
| M . . . M |                @ o o o o o @
| . .     . |                8           o
| .   .   . | -- @ @ @ @ --> 8  Server   o
| .     . . |    Internet    8           o
| M . . . M |                @ o o o o o @
@-----------@
````

A Device is that which contains the sensors (a.k.a Models) like a Voltmeter or a Thermometer. It is the one in charge of assembling the "Device Data Packets", which are the collection of readings from its models. The API offers these operations:

| Operation   | Method  | Url                   | Description                           |
|:-----------:|:-------:|-----------------------|---------------------------------------|
|   `get`     | GET     | `/celeste/devices/`   | Gets a device and its information.    |
|   `insert`  | POST    | `/celeste/devices/`   | Inserts a new device into the DB.     |
|   `remove`  | DELETE  | `/celeste/devices/`   | Deletes a device on the DB along with its associated records. |
| `add_model` | POST    | `/celeste/devices`    | Add a Model to the Device.            |

## `get`
### Request
We can query the details for a device using the following JSON format:

````
{
	"DeviceId" : integer
}
````

Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `DeviceId`  | Required  | Unique identifier for the device. |

### Response
````http
Status Code:    200
Status Message: OK
````
````
{
	"ClientId" : integer,
	"id"  : integer,
	"man" : string,
	"mod" : string,
	"sn"  : string
}
````

## `insert`
### Request
We can insert a new device into the database with the following format:

````
{
    "autogen"  : bool,
    "DeviceId" : integer,
    "ClientId" : integer,
    "man" : string,
    "mod" : string,
    "sn"  : string    
}
````

Where:

| Field       | R/O       | Description                                      |
|:-----------:|:---------:|--------------------------------------------------|
| `autogen`   | Required  | `true` to generate automatically the `DeviceId`. |
| `DeviceId`  | Required  | Unique identifier for the device.                |
| `ClientId`  | Optional  | Unique identifier that represents the client which *owns* the device. This field is optional and thus can be `null`.                   |
| `man`       | Required  | Manufacturer of the device.                      |
| `mod`       | Required  | Model of the device.                             |
| `sn`        | Required  | Serial number of the device.                     |


### Response
````http
Status Code:    200
Status Message: OK
````

If `autogen` was not set then it returns an empty body. Else:

````
{
	DeviceId : integer
}
````
Where `DeviceId` is the autogenerated identifier for the device.


## `remove`
The `remove` operation will delete the device on the database **along with every and any record** that the device has sent. **This cannot be undone**.
### Request
````
{
	"DeviceId" : integer
}
````
Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `DeviceId`  | Required  | Unique identifier for the device. |

### Response
````http
Status Code:    200
Status Message: OK
````
If one attempts to `remove` a device which does not exist in the database, then the operation will return the response.

## `add_model`
Adds a model to a device. This action associates a model to a device so that it is understood as *the device with identifier `device_id` has a model `model_id`*.

### Request
````
{
	"DeviceId" : integer
	"ModelId" : string
	"note" : string
}
````
Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `DeviceId`  | Required  | Unique identifier for the model. Must already exist in the database.  |
| `ModelId`   | Required  | Unique identifier for the model. Must already exist in the database. |
| `note`   | Optional  | A note about the model. This may be used to differentiate a duplicate model that was already associated to the device. An example might be its location: `"note" : "Roof"`.|

### Response
````http
Status Code:    200
Status Message: OK
````

````
{
	"x" : integer
}
````
The field `x` indicates the index of the inserted model. For example, it will return 
`{
	"x" : 2
}`
if a model duplicated model is added.

### Example
Let's assume we have a device with identifier `DeviceId = 4001`. Let's also assume that we have inserted a model named `PowerMeter` which measures, for example, watts. We would like to tell the server that Device `4001` has a model `PowerMeter`. 

````
 -----------                       ------------
|  Device   | - - - - - - - - - - | PowerMeter |
| Id: 4001  |    reads from        ------------
 -----------
````

Our request would look like:

````
{
	"DeviceId" : 4001
	"ModelId" : "PowerMeter"
}
````


# Model
````
    is read by
M @-------------\
M @--------------\
.                 \            @ - - - - - - - - @
.                 [D]          |  M is a Model   |
.                 /            |  D is a Device  |
M @--------------/             @ - - - - - - - - @
M @-------------/

````
A Model can be a sensor or system such as:

- GPS
- Voltmeter
- Thermometer
- Ammeter

Each Model measures a set of Points. For example, a GPS measures latitude, altitude and longitude. On the other hand, an Ammeter measures the current of an electric circuit. A Device may read various Models and is allowed to have more than two similar Models. For instance, it might have two Thermometers. See `add_model` in the [Device](#device) section for more information.


| Operation   | Method  | Url                   | Description                        |
|:-----------:|:-------:|-----------------------|------------------------------------|
|   `get`     | GET     | `/celeste/models/`    | Gets a model and its information. |
|   `insert`  | POST    | `/celeste/models/`    | Inserts a new model into the DB.  |
|   `remove`  | DELETE  | `/celeste/models/`    | Deletes a model on the DB along with its associated records.                                                              |

## `get`
### Request
We can query the details for a device using the following JSON format:

````
{
	"ModelId" : string
}
````

Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `ModelId`   | Required  | Unique identifier for the model.  |

### Response
````http
Status Code:    200
Status Message: OK
````
````
{
	"id": string,
	"ns": string
}
````

## `insert`
### Request
We can insert a new device into the database with the following format:

````
{
	"ModelId" : integer,
	"ns" : string
}
````

Where:

| Field       | R/O       | Description                          |
|:-----------:|:---------:|--------------------------------------|
| `ModelId`   | Required  | Unique identifier for the Model.     |
| `ns`        | Optional  | Namespace or Notes for the Model. One may use this to annotate this particular model.                                  |



### Response
````http
Status Code:    200
Status Message: OK
````

## `remove`
The `remove` operation will delete the model on the database **along with every and any record** that the model has sent. **This cannot be undone**.
### Request
````
{
	"ModelId" : integer
}
````
Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `ModelId`  | Required  | Unique identifier for the model.   |

### Response
````http
Status Code:    200
Status Message: OK
````
If one attempts to `remove` a device which does not exist in the database, then the operation will return the response.

# Point

````
   is sampled by
P @-------------\
P @--------------\          @ - - - - - - - - @
.                 \         |  P is a Point   |
.                 [M]       |  M is a Model   |
.                 /         @ - - - - - - - - @ 
P @--------------/
P @-------------/
````

Points are measurements taken by `Models`. These points can be samples
such as:

- Amperage
- Wattage
- Latitude
- Longitude
- Altitude
- Temperature


| Operation   | Method  | Url                   | Description                           |
|:-----------:|:-------:|-----------------------|---------------------------------------|
|   `get`     | GET     | `/celeste/points/`   | Gets a point and its information.    |
|   `insert`  | POST    | `/celeste/points/`   | Inserts a new point into the DB.     |
|   `remove`  | DELETE  | `/celeste/points/`   | Deletes a point on the DB along with its associated records. |

# Reading
The Reading resource is a very important part of the Celeste system. It allows to query the server for a measurement of, for example, the power consumption. There are various different types of reading such as `last` and `range`. The API user must know the difference between any of these. To this end, we the following table makes it easy to see all the types available.

| Reading     | Description                                      |
|:-----------:|--------------------------------------------------|
|  `last`     | Gets the last reading from a sensor on a device. |
|  `range`    | Gets a range of readings from one starting date to an ending date|

## Requesting a Reading
To request the server for a reading, you must send certain parameters that allow the server to answer back with the data. In general, **all reading requests will require the following 4 parameters**:

| Parameter   | Description                                      |
|:-----------:|--------------------------------------------------|
|  `DeviceId` | Unique identifier of a device.                   |
|  `ModelId`  | Unique identifier of a model on the device.      |
|  `PointId`  | Unique identifier of a point which belongs to the model. |
|  `method`   | Which reading method to use. E.g. `"last"`, `"range"`, etc.

These three parameters allow the server to pinpoint exactly which measurement we want to query. Thus the request body for the reading will look like:

````
{
	"DeviceId" : integer,
	"ModelId" : string,
	"PointId" : string
	"method" : string
	
	// Other parameters
	// ...
}
````

To summarize, every request shall require the four mentioned parameters.
There, however, might be more parameters for other types of reading and each reading will have a different response depending on `method`. The following sections will formalize these details.

## `last`

This action obtains the last reading recorded by a device. For example, we might have a Device which logs the temperature from a Thermometer every 10 minutes. There will be many records available in the DB. Namely, every single record from the start of logging to the current time. It is often of interest to consult the last reading logged by the device. In order to do this we set the method to `"method" : "last"`. No other parameters, except the ones mentioned in "Requesting a Reading" are needed.

### Response
````http
Status Code:    200
Status Message: OK
````

````
{
	"value" : string, integer, double
	"t" : string
}
````
Where:

| Field     | Description                                      |
|:---------:|--------------------------------------------------|
|  `value`  | Value of the reading. The type of the value may be one of the following: `string`, `integer`, `double` |
|  `t`      | Timestamp indicating time and date when the measurement took place.|

## `range` 

To obtain a range of readings we first define what we mean. A *range of readings* is an ordered list of values. The list* is ordered in **ascending order** starting with the earliest date, down to the latest. For this reading, we need two extra parameters: `start` and `end` where `end > start`. That is, `end` is the later date. To employ this method we set `"method" : "last"`.

| Parameter   | Description                                      |
|:-----------:|--------------------------------------------------|
|  `start`    | Start date. |
|  `end`      | End date.   |

**\*The range is inclusive from both sides.**

### Response
The response an ordered JSON array of values with their timestamps in ascending order, starting with the earliest date.

````http
Status Code:    200
Status Message: OK
````
````
[
	{
		"value" : value1
		"t" : timestamp1
	},
	{
		"value" : value2
		"t" : timestamp2
	},
	.
	.
	.
	{
		"value" : valueN
		"t" : timestampN
	}
]
````


### Example
An example might be taking requesting all the readings from a Thermometer on a Device with id `4001` from `21-12-2017 00:00:01` to `22-12-2017 00:00:01`. The request will look like:

````
{
	"DeviceId" : 4001,
	"ModelId" : "Thermometer",
	"PointId" : "Temperature"
	"method" : "range",
	
	"start" : "21-12-2017 00:00:01",
	"end" : "22-12-2017 00:00:01"
}
````
The response might look like:

````
[
	{
		"value" : 20.2
		"t" : 21-12-2017 00:00:01
	},
	{
		"value" : 27.4
		"t" : 21-12-2017 08:00:01
	},
	{
		"value" : 35.1
		"t" : 21-12-2017 16:00:01
	},
	{
		"value" : 21.7
		"t" : 22-12-2017 00:00:01
	}
]
````

# Logger
Like the [Reading](#reading) resource, the Logger resource is one of the most important parts of the whole Celeste system. This is the resource which will listen for incoming records sent by the Devices. This being said, there are 3 specific formats which the logger will understand: XML, JSON and CelesteRN. Currently only XML is supported.

It will be necessary to specify the following headers whenever you use the logger:

````http
Content-Length: length
Content-Type:   application/xml
````
| Header            | Description                           |
|:-----------------:|---------------------------------------|
| `Content-Length`  | The number of characters in the body. |
| `Content-Type`    | One of the following: <br/> `application/xml` <br/> `application/json`<br/> `application/CelesteRN`             |



## Uploading to the Logger
To upload to the Logger, one must send their data to the URL:

`http://[host]:[port]/celeste/logger/upload` 

as a POST method. The server will then answer back with a `200` code only if the records were accepted and no errors were found. This is summarized in the following table:

| Operation   | Method  | Url                           |
|:-----------:|:-------:|-------------------------------|
|   `upload`  | POST    | `/celeste/logger/upload/`     |
|   `upload`  | POST    | `/celeste/logger/upload/verbose?=[0 or 1]`      |

The first path will be interpreted as `verbose?=0`. That is, no verbose response.

### Request
We have said that the server will only accept a handful of structured formats. The intention of this section is to give the formal formats that are required.

#### XML
The following is the format to send the records in:

````xml
<SunSpecData v="1.0">
    <d id="[0-9]+" lid="[0-9]+" t="YYYY-MM-DD HH:MM:SS">
        <m id="[a-zA-Z]+" x="[0-9]+">
        	<p id="[a-zA-Z]+" sf="[0-9]+" t="YYY-MM-DD HH:MM:SS">
        		VALUE
        	</p>
        	...
        </m> 
    	...
    </d>
    ...
</SunSpecData>
````
The `...` is meant to indicate a list. So clearly  `SunSpecData` contains a list of `Devices`. Each Device `d` contains a list of Models. Each Model `m` contains a list of Points. Each Point `p` only contains a value. This value may be a `string` or a `number`. 

#### Tag Table
Not all of the attributes defined in the grammar are mandatory. It proves useful to build a table to indicate what each of these tags mean and whether they are optional or mandatory.

| Tag     | R/O      | Description                                                  |
|:-------:|:--------:|--------------------------------------------------------------|
| `v`     | Required | Version number of grammar.                                   |
| `d.id`  | Required | Identifier of Device. E.g. 1443                              |
| `d.t`   | Required | Timestamp at which the records were assembled.               |
| `d.lid` | Optional | Identifier of the Logger which the Device sends its data to. |
| `m.id`  | Required | Identifier of the Model. E.g. Thermometer.                   |
| `m.x`   | Required | Aggregated index of the Model on the Device. Used to differentiate between two identical models on the Device. |
| `p.id`  | Required | Identifier of the Point on the Model. E.g. Celsius.
| `p.sf`  | Optional | Scale factor to use. Needed to calculate: `scaled_value = value * 10^(sf)`. If not specified then default value is `0`.
| `p.t`   | Optional | Timestamp at which the measurement was taken.

### Response
#### Success
A succesful response implies that the records we succesfully persisted into the database and no errors were found. As of writing, it is of no interest to answer back with a verbose message to indicate success. Therefore, the HTTP response will look like:

````http
Status Code:    200
Status Message: OK
HTTP Version:   1.1
HTTP Protocol:  HTTP
````

#### Failure
On failure, if `verbose?=1` then it will answer back with a verbose message. If `verbose?=0` we can expect to only receive a response like the one shown before. That will mostly (and only) depend on the status code. Practically, the non-verbose versions will be the same as the verbose ones, only they won't have the body. Thus, if one reads the following verbose responses, then one knows their non-verbose versions. For each response, we give the HTTP status code returned and what the body will look like. One may notice that the HTTP codes and the `status` field in the response body **will not coincide**. This is expected since they have another meaning. As of current writing, it is in development more specific error messages and codes. The HTTP codes will remain the same, but more codes for the sub-protocol will be added. For now, it is sufficient to follow the HTTP error semantics. 

##### Parsing Error

````http
Status Code:    400
Status Message: BAD REQUEST
````

````xml
<SunSpecDataResponse>
	<status> 400 </status>
	<code> FAILURE </code>
	<reason> Parsing Error </reason>
	<message>
		[Message indicating where the error is]
	</message>
</SunSpecDataResponse>
````


##### Database Error

````http
Status Code:    500
Status Message: INTERNAL SERVER ERROR
````

````xml
<SunSpecDataResponse>
	<status> 400 </status>
	<code> FAILURE </code>
	<reason> Parsing Error </reason>
	<message>
		[Message explaining why the insertion to the database failed]
	</message>
</SunSpecDataResponse>
````

## XML Example
To make the usage of the grammar simpler, we will give an example. Suppose we would like to save some records by a Device with only one Thermometer. Firstly we need to pinpoint the Device by its identifier. Say this Device in particular has the identifier `4001`. The scheme will then look like this:

````
@ - - - - - - - - - @
| Date: 2017-11-21  |
| Time: 15:30:01    |
@ - - - - - - - - - @

                      [Thermometer] = 30 C
                             |
                             |
 -----------                 |             @ o o o o o o @
|  Device   |- - - - - - - - +             8             o
| Id: 4001  |- - - - @ @ @ @ @ @ - - - - > 8   Celeste   o
 -----------           Internet            8    Server   o
                    [ Data Packet ]        8             o
                                           @ o o o o o o @
````

We would like to know what `[Data Packet]` looks like. As we have said previously, this data will take the form of an HTTP Response with the body containing the information of the actual measurements. We notice that we would like to tell the server we have recorded a reading of `30` degrees celsius and we assembled the packet at the date and time shown. It is of use to give the values which each field takes at this instance.

| Tag     | Value                 |
|:-------:|:---------------------:|
| `v`     | 1.0                   |
| `d.id`  | 4001                  |
| `d.t`   | 2017-11-21 15:30:01   |
| `m.id`  | Thermometer           |
| `m.x`   | 1                     |
| `p.id`  | Temperature           |

Translating over to XML we get:

````xml
<SunSpecData v="1.0">
    <d id="4001" t="2017-11-21 15:30:01">
    	<m id="Thermometer" x="1">
    		<p id="Temperature">
    			30
    		</p>
    	</m> 
    </d>
</SunSpecData>
````

One need not worry about the units of measurement since it is required to specify them when one first inserts a Point into the database.

# Full Example
To write.


# Notes

- All the timestamps must be in UTC Posix format.
