# Overview
This is the documentation for the Celeste HTTP API. 

# Table of Contents


1.  [Overview](#overview)
2.  [Device](#device)
3.  [Model](#model)
4.  [Point](#point)
5.  [Reading](#reading)
6.  [Logger](#logger)

# Device

````
@ - - - - - - - - @
|  M is a Model   |
@ - - - - - - - - @

   Device
@-----------@
| M . . . M |                @ o o o o o @
| . .     . |                8           o
| .   .   . | -- @ @ @ @ --> 8  Server   o
| .     . . |    Internet    8           o
| M . . . M |                @ o o o o o @
@-----------@
````

A Device is that which contains the sensors (a.k.a Models) like a Voltmeter or a Thermometer. It is the one in charge of assembling the "Device Data Packets", which are the collection of readings from its models. The API offers these operations:

| Operation   | Method  | Url                   | Description                        |
|:-----------:|:-------:|-----------------------|------------------------------------|
|   `get`     | GET     | `/celeste/devices/`   | Gets a device and its information. |
|   `insert`  | POST    | `/celeste/devices/`   | Inserts a new device into the DB.  |
|   `remove`  | DELETE  | `/celeste/devices/`   | Deletes a device on the DB along with its associated records.                                                              |

## `get`
### Request
We can query the details for a device using the following JSON format:

````
{
	"DeviceId" : integer
}
````

Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `DeviceId`  | Required  | Unique identifier for the device. |

### Response
````
[
	{
		"Client_id" : integer / null,
		"id"  : integer,
		"man" : string,
		"mod" : string,
		"sn"  : string
	}
]
````

## `insert`
### Request
We can insert a new device into the database with the following format:

````
{
    "autogen"  : bool,
    "DeviceId" : integer,
    "ClientId" : integer / null,
    "man" : string,
    "mod" : string,
    "sn"  : string    
}
````

Where:

| Field       | R/O       | Description                                      |
|:-----------:|:---------:|--------------------------------------------------|
| `autogen`   | Required  | `true` to generate automatically the `DeviceId`. |
| `DeviceId`  | Required  | Unique identifier for the device.                |
| `ClientId`  | Optional  | Unique identifier that represents the client which *owns* the device. This field is optional and thus can be `null`.                   |
| `man`       | Required  | Manufacturer of the device.                      |
| `mod`       | Required  | Model of the device.                             |
| `sn`        | Required  | Serial number of the device.                     |


### Response
````
Status Code:    200
Status Message: OK
````

If `autogen` was not set then it returns an empty body. Else:

````
{
	DeviceId : integer
}
````
Where `DeviceId` is the autogenerated identifier for the device.


## `remove`
The `remove` operation will delete the device on the database **along with every and any record** that the device has sent. **This cannot be undone**.
### Request
````
{
	"DeviceId" : integer
}
````
Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `DeviceId`  | Required  | Unique identifier for the device. |

### Response
````
Status Code:    200
Status Message: OK
````
If one attempts to `remove` a device which does not exist in the database, then the operation will return the response.

# Model
````
    is read by
M @-------------\
M @--------------\
.                 \            @ - - - - - - - - @
.                 [D]          |  M is a Model   |
.                 /            |  D is a Device  |
M @--------------/             @ - - - - - - - - @
M @-------------/

````
A Model can be a sensor

| Operation   | Method  | Url                   | Description                        |
|:-----------:|:-------:|-----------------------|------------------------------------|
|   `get`     | GET     | `/celeste/models/`    | Gets a model and its information. |
|   `insert`  | POST    | `/celeste/models/`    | Inserts a new model into the DB.  |
|   `remove`  | DELETE  | `/celeste/models/`    | Deletes a model on the DB along with its associated records.                                                              |

## `get`
### Request
We can query the details for a device using the following JSON format:

````
{
	"DeviceId" : integer
}
````

Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `DeviceId`  | Required  | Unique identifier for the device. |

### Response
````
[
	{
		"Client_id" : integer / null,
		"id"  : integer,
		"man" : string,
		"mod" : string,
		"sn"  : string
	}
]
````

## `insert`
### Request
We can insert a new device into the database with the following format:

````
{
    "autogen"  : bool,
    "DeviceId" : integer,
    "ClientId" : integer / null,
    "man" : string,
    "mod" : string,
    "sn"  : string    
}
````

Where:

| Field       | R/O       | Description                                      |
|:-----------:|:---------:|--------------------------------------------------|
| `autogen`   | Required  | `true` to generate automatically the `DeviceId`. |
| `DeviceId`  | Required  | Unique identifier for the device.                |
| `ClientId`  | Optional  | Unique identifier that represents the client which *owns* the device. This field is optional and thus can be `null`.                   |
| `man`       | Required  | Manufacturer of the device.                      |
| `mod`       | Required  | Model of the device.                             |
| `sn`        | Required  | Serial number of the device.                     |


### Response
````
Status Code:    200
Status Message: OK
````

If `autogen` was not set then it returns an empty body. Else:

````
{
	DeviceId : integer
}
````
Where `DeviceId` is the autogenerated identifier for the device.


## `remove`
The `remove` operation will delete the device on the database **along with every and any record** that the device has sent. **This cannot be undone**.
### Request
````
{
	"DeviceId" : integer
}
````
Where:

| Field       | R/O       | Description                       |
|:-----------:|:---------:|-----------------------------------|
| `DeviceId`  | Required  | Unique identifier for the device. |

### Response
````
Status Code:    200
Status Message: OK
````
If one attempts to `remove` a device which does not exist in the database, then the operation will return the response.
# Point

````
   is sampled by
P @-------------\
P @--------------\          @ - - - - - - - - @
.                 \         |  P is a Point   |
.                 [M]       |  M is a Model   |
.                 /         @ - - - - - - - - @ 
P @--------------/
P @-------------/
````

  Points are measurements taken by `Models`. These points can be samples
  such as:
  - Amperage
  - Wattage
  - Latitude
  - Longitude
  - Altitude
  - Temperature

# Reading

# Logger
The Logger resource is one of the most important parts of the whole Celeste system. This is the part which processes the data sent to it. This being said, there are 3 specific formats which the server will accept; XML, JSON and CelesteRN. Currently only XML is supported.

## Uploading to the Logger
To upload to the Logger, one must send their data to URL:

`http://[host]:[port]/celeste/logger/upload` 

as a POST method. The server will then answer back with a `200` code only if the records were accepted and no errors were found. This is summarized in the following table:

| Operation   | Method  | Url                           |
|:-----------:|:-------:|-------------------------------|
|   `upload`  | POST    | `/celeste/logger/upload/`     |
|   `upload`  | POST    | `/celeste/logger/upload/verbose?=[0 or 1]`      |

The first path will be interpreted as `verbose?=0`. That is, no verbose response.

### Request
We have said that the server will only accept a handful of structured formats. The intention of this section is to give the formal formats that are required.

#### XML
The following is the format to send the records in:

````xml
<SunSpecData v="1.0">
    <d id="[0-9]+" lid="[0-9]+" t="YYYY-MM-DD HH:MM:SS">
        <m id="[a-zA-Z]+" x="[0-9]+">
        	<p id="[a-zA-Z]+" sf="[0-9]+" t="YYY-MM-DD HH:MM:SS">
        		VALUE
        	</p>
        	...
        </m> 
    	...
    </d>
    ...
</SunSpecData>
````
The `...` is meant to indicate a list. So clearly  `SunSpecData` contains a list of `Devices`. Each Device `d` contains a list of Models. Each Model `m` contains a list of Points. Each Point `p` only contains a value. This value may be a `string` or a `number`. 

#### Tag Table
Not all of the attributes defined in the grammar are mandatory. It proves useful to build a table to indicate what each of these tags mean and whether they are optional or mandatory.

| Tag     | M/O     | Description                                                  |
|:-------:|:-------:|--------------------------------------------------------------|
| `v`     | M       | Version number of grammar.                                   |
| `d.id`  | M       | Identifier of Device. E.g. 1443                              |
| `d.t`   | M       | Timestamp at which the records were assembled.               |
| `d.lid` | O       | Identifier of the Logger which the Device sends its data to. |
| `m.id`  | M       | Identifier of the Model. E.g. Thermometer.                   |
| `m.x`   | M       | Aggregated index of the Model on the Device. Used to differentiate between two identical models on the Device. |
| `p.id`  | M       | Identifier of the Point on the Model. E.g. Celsius.
| `p.sf`  | O       | Scale factor to use. Needed to calculate: `scaled_value = value * 10^(sf)`. If not specified then default value is `0`.
| `p.t`   | O       | Timestamp at which the measurement was taken.

### Response
#### Success
A succesful response implies that the records we succesfully persisted into the database and no errors were found. As of writing, it is of no interest to answer back with a verbose message to indicate success. Therefore, the HTTP response will look like:

````http
Status Code:    200
Status Message: OK
HTTP Version:   1.1
HTTP Protocol:  HTTP
````

#### Failure
On failure, if `verbose?=1` then it will answer back with a verbose message. If `verbose?=0` we can expect to only receive a response like the one shown before. That will mostly (and only) depend on the status code. Practically, the non-verbose versions will be the same as the verbose ones, only they won't have the body. Thus, if one reads the following verbose responses, then one knows their non-verbose versions. For each response, we give the HTTP status code returned and what the body will look like. One may notice that the HTTP codes and the `status` field in the response body **will not coincide**. This is expected since they have another meaning. As of current writing, it is in development more specific error messages and codes. The HTTP codes will remain the same, but more codes for the sub-protocol will be added. For now, it is sufficient to follow the HTTP error semantics. 

##### Parsing Error

````
Status Code:    400
Status Message: BAD REQUEST
````

````xml
<SunSpecDataResponse>
	<status> 400 </status>
	<code> FAILURE </code>
	<reason> Parsing Error </reason>
	<message>
		[Message indicating where the error is]
	</message>
</SunSpecDataResponse>
````


##### Database Error

````xml
Status Code:    500
Status Message: INTERNAL SERVER ERROR
````

````xml
<SunSpecDataResponse>
	<status> 400 </status>
	<code> FAILURE </code>
	<reason> Parsing Error </reason>
	<message>
		[Message explaining why the insertion to the database failed]
	</message>
</SunSpecDataResponse>
````

## XML Example
To make the usage of the grammar simpler, we will give an example. Suppose we would like to save some records by a Device with only one Thermometer. Firstly we need to pinpoint the Device by its identifier. Say this Device in particular has the identifier `4001`. The scheme will then look like this:

````
@ - - - - - - - - - @
| Date: 2017-11-21  |
| Time: 15:30:01    |
@ - - - - - - - - - @

                      [Thermometer] = 30 C
                             |
                             |
 -----------                 |             @ o o o o o o @
|  Device   |- - - - - - - - +             8             o
| Id: 4001  |- - - - @ @ @ @ @ @ - - - - > 8   Celeste   o
 -----------           Internet            8    Server   o
                    [ Data Packet ]        8             o
                                           @ o o o o o o @
````

We would like to know what `[Data Packet]` looks like. As we have said previously, this data will take the form of an HTTP Response with the body containing the information of the actual measurements. We notice that we would like to tell the server we have recorded a reading of `30` degrees celsius and we assembled the packet at the date and time shown. It is of use to give the values which each field takes at this instance.

| Tag     | Value                 |
|:-------:|:---------------------:|
| `v`     | 1.0                   |
| `d.id`  | 4001                  |
| `d.t`   | 2017-11-21 15:30:01   |
| `m.id`  | Thermometer           |
| `m.x`   | 1                     |
| `p.id`  | Temperature           |

Translating over to XML we get:

````xml
<SunSpecData v="1.0">
    <d id="4001" t="2017-11-21 15:30:01">
        <m id="Thermometer" x="1">
        	<p id="Temperature">
        		30
        	</p>
        </m> 
    </d>
</SunSpecData>
````

One need not worry about the units of measurement since it is required to specify them when one first inserts a Point into the database.